import asyncio
import logging
import time
import uuid
from fastapi import (
    APIRouter,
    HTTPException,
    Depends,
    WebSocket,
    WebSocketDisconnect,
)
from typing import Annotated, Any, Coroutine, Iterable
from pydantic import BaseModel, ValidationError
from sqlmodel import Session as DatabaseSession

from app.dependencies import (
    get_db_session,
    authenticate,
    get_session_manager,
)
from app.database.setup import (
    Answer,
    AnswerCreate,
    AnswerPublicExtended,
    Question,
    QuestionCreate,
    Quiz,
    SentimentAnalysis,
    Summary,
    SummaryPublic,
    Topic,
    TopicExtended,
)
from app.internal.analysis import (
    perform_sentiment_analysis,
    perform_summarisation,
    perform_topic_modelling,
    perform_topic_summarisation,
)
from app.internal.session_manager import SessionManager
from app.internal.session import (
    Session,
    SessionCreate,
    SessionPublic,
    SessionStage,
)
from app.internal.ws_helpers import (
    SessionErrorPayload,
    ClientSessionMessageType,
    receive_session_message,
    send_session_message,
)

from sqlmodel import select
from app.database.setup import Question
from processing.definitions import Answer as AnalysisAnswer

logger = logging.getLogger("app")

router = APIRouter()


class ResponseBase(BaseModel):
    message: str


# region Session management


@router.post("/", operation_id="create_session")
async def create_session(
    body: SessionCreate,
    user_id: Annotated[str, Depends(authenticate)],
    db: Annotated[DatabaseSession, Depends(get_db_session)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Create a session and link it to the current user and a quiz.
    """
    quiz_provided = body.quiz_id is not None

    if quiz_provided:
        # Ensure that the provided quiz id is valid
        quiz = db.get(Quiz, body.quiz_id)
        if not quiz:
            raise HTTPException(
                status_code=404, detail="Quiz not found for provided quiz id"
            )
    else:
        # Generate new quiz id if not provided
        body.quiz_id = uuid.uuid4()

    session = await session_manager.create_session(
        user_id=user_id, quiz_id=body.quiz_id
    )
    if not session:
        raise HTTPException(
            status_code=500, detail="Unable to create session, please retry"
        )

    if not quiz_provided:
        # Create and store the new quiz with the generated quiz id
        db_quiz = Quiz(
            id=body.quiz_id,
            user_id=user_id,
            name=f"Quiz {session.id}",
            description=f"Autogenerated quiz for session {session.id}",
        )
        db.add(db_quiz)
        db.commit()
        db.refresh(db_quiz)
        logger.debug(
            "New quiz autogenerated for session",
            extra={"session_id": session.id, "quiz_id": db_quiz.id},
        )

    return session.get_public()


@router.get("/{session_id}", operation_id="get_session")
async def get_session(
    session_id: str,
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Get session details, including status, current question, answers, and audience count.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    return session.get_public()


@router.get("/quiz/{quiz_id}", operation_id="get_session_by_quiz")
async def get_session_by_quiz(
    quiz_id: uuid.UUID,
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Get session details by quiz_id.
    """
    session = await session_manager.get_session_from_quiz(quiz_id=quiz_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session for quiz not found")
    return session.get_public()


@router.post(
    "/{session_id}/transitions/askquestion",
    operation_id="ask_question_transition",
)
async def ask_question_transition(
    session_id: str,
    user_id: Annotated[str, Depends(authenticate)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Transition to the ask_question stage and notify the clients.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    if user_id != session.owner_id:
        raise HTTPException(
            status_code=403,
            detail="Only the session owner can initiate a stage transition",
        )

    session.stage = SessionStage.AskQuestion
    await session_manager.broadcast(session=session)

    return session.get_public()


@router.post(
    "/{session_id}/transitions/awaitanswers",
    operation_id="await_answers_transition",
)
async def await_answers_transition(
    session_id: str,
    question: QuestionCreate,
    user_id: Annotated[str, Depends(authenticate)],
    db: Annotated[DatabaseSession, Depends(get_db_session)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Submit a new question, transition to the await_answers and notify the clients.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    if user_id != session.owner_id:
        raise HTTPException(
            status_code=403,
            detail="Only the session owner can initiate a stage transition",
        )

    # Store the question in the database
    db_question = Question.model_validate(question, update={"user_id": user_id})
    db.add(db_question)
    db.commit()
    db.refresh(db_question)

    session.stage = SessionStage.AwaitAnswers
    session.current_question = db_question
    session.current_answers = []
    await session_manager.broadcast(session=session)
    await session.start_worker()

    return session.get_public()


@router.post(
    "/{session_id}/transitions/showanalyses", operation_id="show_analyses_transition"
)
async def show_analyses_transition(
    session_id: str,
    user_id: Annotated[str, Depends(authenticate)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> SessionPublic:
    """
    Transition to the show_analyses stage and notify the clients.
    This is used to skip an ongoing question or signal that the time is up.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    if not user_id == session.owner_id:
        raise HTTPException(
            status_code=403,
            detail="Only the session owner can initiate a stage transition",
        )

    session.stage = SessionStage.ShowAnalyses
    await session_manager.broadcast(session=session)
    await session.stop_worker()

    return session.get_public()


@router.post("/{session_id}/kill", operation_id="kill_session")
async def kill_session(
    session_id: str,
    user_id: Annotated[str, Depends(authenticate)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> ResponseBase:
    """
    Kill the session (only the owner can do this).
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    if user_id != session.owner_id:
        raise HTTPException(
            status_code=403, detail="Only the session owner can kill the session"
        )

    await session_manager.kill_session(session=session)

    return ResponseBase(message="Session killed")


# endregion
# region Analyses


class OverallAnalysis(BaseModel):
    summary: SummaryPublic | None
    answers: Iterable[AnswerPublicExtended]


@router.get("/{session_id}/analyses/overall", operation_id="overall_analysis")
async def overall_analysis(
    session_id: str,
    db: Annotated[DatabaseSession, Depends(get_db_session)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> OverallAnalysis:
    """
    Perform sentiment analysis on all answers to the question and create an LLM summary.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    quiz = db.get(Quiz, session.quiz_id)
    if not quiz:
        raise HTTPException(status_code=400, detail="Quiz not found for session")
    question = session.current_question
    if not question:
        raise HTTPException(
            status_code=400, detail="No active question in this session"
        )

    start_time = time.monotonic()

    # Get the prepared answers of the session and ensure the preparation finishes
    prepared_answers = await session.get_prepared_answers()

    # Retrieve summary from database if it exists
    db_summary = db.exec(
        select(Summary).where(
            (Summary.question_id == question.id) & (Summary.topic_id == None)
        )
    ).first()

    # Run summarisation if necessary
    if not db_summary:
        try:
            db_summary = await perform_summarisation(
                db=db,
                quiz=quiz,
                question=question,
                prepared_answers=prepared_answers,
                audience_count=session.audience_count(),
            )
            db.refresh(db_summary)
        except Exception as e:
            logger.debug(
                "Summarisation failed for the question",
                extra={"question_id": question.id},
                exc_info=e,
            )
            db.rollback()
    await session.await_sentiments()

    # Retrieve the updated answers
    db_answers_statement = select(Answer).where(Answer.question_id == question.id)
    db_answers = db.exec(db_answers_statement).all()

    logger.debug(f"Time overall analysis: {time.monotonic() - start_time}s")
    return OverallAnalysis(summary=db_summary, answers=db_answers)


class DetailedAnalysis(BaseModel):
    topics: Iterable[TopicExtended]


@router.get("/{session_id}/analyses/detailed", operation_id="detailed_analysis")
async def detailed_analysis(
    session_id: str,
    db: Annotated[DatabaseSession, Depends(get_db_session)],
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> DetailedAnalysis:
    """
    Perform topic modelling on all answers to the question, retrieve related sentiments
    and create an LLM summary for each topic.
    """
    session = await session_manager.get_session(session_id=session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    quiz = db.get(Quiz, session.quiz_id)
    if not quiz:
        raise HTTPException(status_code=400, detail="Quiz not found for session")
    question = session.current_question
    if not question:
        raise HTTPException(
            status_code=400, detail="No active question in this session"
        )

    start_time = time.monotonic()

    # Get the prepared answers of the session and ensure the preparation finishes
    prepared_answers = await session.get_prepared_answers()

    # Retrieve topics for question from database if any exist
    db_topic_statement = select(Topic).where(Topic.question_id == question.id)
    db_topics = db.exec(db_topic_statement).all()

    # Perform topic modelling if necessary. Return early if it fails.
    if not db_topics:
        try:
            db_topics = await perform_topic_modelling(
                db=db,
                question=question,
                prepared_answers=prepared_answers,
            )
        except Exception as e:
            logger.debug(
                "Topic modelling task failed for the question",
                extra={"question_id": question.id},
                exc_info=e,
            )
            db.rollback()
            return DetailedAnalysis(topics=[])

    # Perform summarisation for topics that are without a summary
    topics_without_summary = [topic for topic in db_topics if topic.summary is None]
    if topics_without_summary:
        try:
            await perform_topic_summarisation(
                db=db,
                quiz=quiz,
                topics=topics_without_summary,
                prepared_answers=prepared_answers,
                audience_count=session.audience_count(),
            )
        except Exception as e:
            logger.debug(
                "Topic summarisation task failed for a question",
                extra={"question_id": question.id},
                exc_info=e,
            )
            db.rollback()

    # Retrieve the final topics. Needed to get the related sentiments and summaries.
    db_topics = db.exec(db_topic_statement).all()

    logger.debug(f"Time detailed analysis: {time.monotonic() - start_time}s")
    return DetailedAnalysis(topics=db_topics)


# endregion
# region Websocket


async def handle_answer(session: Session, payload: dict) -> SessionErrorPayload | None:
    """
    Handle an answer sent by a user (via WebSocket).
    We create/close our own short-lived DB session to avoid holding a connection forever.
    """
    if not session.stage == SessionStage.AwaitAnswers:
        logger.debug(
            "New answers are not accepted in the current session stage",
            extra={"session_id": session.id, "session_stage": session.stage},
        )
        return SessionErrorPayload(
            message="New answers are not accepted in the current session stage"
        )

    from app.database.setup import SessionLocal  # local import for clarity

    try:
        answer = AnswerCreate.model_validate(payload)
        # Insert into DB in a short-lived session
        with SessionLocal() as db:
            db_answer = Answer.model_validate(answer)
            db.add(db_answer)
            db.commit()
            db.refresh(db_answer)

        session.register_answer(answer=db_answer)
    except ValidationError as e:
        logger.debug(
            "Invalid answer payload",
            extra={"session_id": session.id},
            exc_info=e,
        )
        return SessionErrorPayload(message="Invalid answer payload")


@router.websocket("/ws/{session_id}")
async def websocket_endpoint(
    session_id: str,
    socket: WebSocket,
    session_manager: Annotated[SessionManager, Depends(get_session_manager)],
) -> None:
    """
    WebSocket endpoint to manage real-time communication for a session with audience.
    """
    await socket.accept()

    # Join session and register connection in the manager
    session = await session_manager.join_session(
        session_id=session_id,
        connection=socket,
    )
    if not session:
        await socket.close(code=1003, reason="Session does not exist or is not active")
        return

    # Synchronise frontend with current session
    await send_session_message(socket=socket, session=session)

    while True:
        try:
            message = await receive_session_message(socket)

            match message.type:
                case ClientSessionMessageType.Answer:
                    error = await handle_answer(
                        session=session,
                        payload=message.payload,
                    )
                    await send_session_message(
                        socket=socket,
                        session=session,
                        error=error,
                    )

        except WebSocketDisconnect:
            logger.debug("WebSocket connection disconnected")
            break
        except Exception as e:
            if isinstance(e, ValidationError):
                log_message = "Invalid session websocket message"
                ws_message = "Invalid websocket message format"
            else:
                log_message = "An unknown exception occurred during session"
                ws_message = "Something went wrong. Please retry"

            logger.warning(log_message, extra={"session_id": session_id}, exc_info=e)
            await send_session_message(
                socket=socket,
                session=session,
                error=SessionErrorPayload(message=ws_message),
            )

    # Clean up after disconnect
    await session_manager.leave_session(session_id=session_id, connection=socket)


# endregion
