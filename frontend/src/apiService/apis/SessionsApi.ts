/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DetailedAnalysis,
  HTTPValidationError,
  OverallAnalysis,
  QuestionCreate,
  ResponseBase,
  SentimentAnalysisPublic,
  SessionCreate,
  SessionPublic,
  SummaryPublic,
  TopicPublic,
} from '../models/index';
import {
    DetailedAnalysisFromJSON,
    DetailedAnalysisToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    OverallAnalysisFromJSON,
    OverallAnalysisToJSON,
    QuestionCreateFromJSON,
    QuestionCreateToJSON,
    ResponseBaseFromJSON,
    ResponseBaseToJSON,
    SentimentAnalysisPublicFromJSON,
    SentimentAnalysisPublicToJSON,
    SessionCreateFromJSON,
    SessionCreateToJSON,
    SessionPublicFromJSON,
    SessionPublicToJSON,
    SummaryPublicFromJSON,
    SummaryPublicToJSON,
    TopicPublicFromJSON,
    TopicPublicToJSON,
} from '../models/index';

export interface AskQuestionTransitionRequest {
    sessionId: string;
}

export interface AwaitAnswersTransitionRequest {
    sessionId: string;
    questionCreate: QuestionCreate;
}

export interface CreateSessionRequest {
    sessionCreate: SessionCreate;
}

export interface DetailedAnalysisRequest {
    sessionId: string;
}

export interface GetSessionRequest {
    sessionId: string;
}

export interface GetSessionByQuizRequest {
    quizId: string;
}

export interface GetTopicsRequest {
    sessionId: string;
}

export interface KillSessionRequest {
    sessionId: string;
}

export interface OverallAnalysisRequest {
    sessionId: string;
}

export interface SentimentRequest {
    sessionId: string;
}

export interface ShowAnalysesTransitionRequest {
    sessionId: string;
}

export interface SummariseRequest {
    sessionId: string;
}

/**
 * 
 */
export class SessionsApi extends runtime.BaseAPI {

    /**
     * Transition to the ask_question stage and notify the clients.
     * Ask Question Transition
     */
    async askQuestionTransitionRaw(requestParameters: AskQuestionTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling askQuestionTransition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/sessions/{session_id}/transitions/askquestion`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Transition to the ask_question stage and notify the clients.
     * Ask Question Transition
     */
    async askQuestionTransition(requestParameters: AskQuestionTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.askQuestionTransitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a new question, transition to the await_answers and notify the clients.
     * Await Answers Transition
     */
    async awaitAnswersTransitionRaw(requestParameters: AwaitAnswersTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling awaitAnswersTransition().'
            );
        }

        if (requestParameters['questionCreate'] == null) {
            throw new runtime.RequiredError(
                'questionCreate',
                'Required parameter "questionCreate" was null or undefined when calling awaitAnswersTransition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/sessions/{session_id}/transitions/awaitanswers`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionCreateToJSON(requestParameters['questionCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Submit a new question, transition to the await_answers and notify the clients.
     * Await Answers Transition
     */
    async awaitAnswersTransition(requestParameters: AwaitAnswersTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.awaitAnswersTransitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a session and link it to the current user and a quiz.
     * Create Session
     */
    async createSessionRaw(requestParameters: CreateSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['sessionCreate'] == null) {
            throw new runtime.RequiredError(
                'sessionCreate',
                'Required parameter "sessionCreate" was null or undefined when calling createSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/sessions/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SessionCreateToJSON(requestParameters['sessionCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Create a session and link it to the current user and a quiz.
     * Create Session
     */
    async createSession(requestParameters: CreateSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.createSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform topic modelling on all answers to the question, retrieve related sentiments and create an LLM summary for each topic.
     * Detailed Analysis
     */
    async detailedAnalysisRaw(requestParameters: DetailedAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DetailedAnalysis>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling detailedAnalysis().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}/analyses/detailed`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DetailedAnalysisFromJSON(jsonValue));
    }

    /**
     * Perform topic modelling on all answers to the question, retrieve related sentiments and create an LLM summary for each topic.
     * Detailed Analysis
     */
    async detailedAnalysis(requestParameters: DetailedAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DetailedAnalysis> {
        const response = await this.detailedAnalysisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get session details, including status, current question, answers, and audience count.
     * Get Session
     */
    async getSessionRaw(requestParameters: GetSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Get session details, including status, current question, answers, and audience count.
     * Get Session
     */
    async getSession(requestParameters: GetSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.getSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get session details by quiz_id.
     * Get Session By Quiz
     */
    async getSessionByQuizRaw(requestParameters: GetSessionByQuizRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['quizId'] == null) {
            throw new runtime.RequiredError(
                'quizId',
                'Required parameter "quizId" was null or undefined when calling getSessionByQuiz().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/quiz/{quiz_id}`.replace(`{${"quiz_id"}}`, encodeURIComponent(String(requestParameters['quizId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Get session details by quiz_id.
     * Get Session By Quiz
     */
    async getSessionByQuiz(requestParameters: GetSessionByQuizRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.getSessionByQuizRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform Topic Modelling analysis on the current answers.
     * Get Topics
     */
    async getTopicsRaw(requestParameters: GetTopicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TopicPublic>>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getTopics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}/analyses/topics`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopicPublicFromJSON));
    }

    /**
     * Perform Topic Modelling analysis on the current answers.
     * Get Topics
     */
    async getTopics(requestParameters: GetTopicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TopicPublic>> {
        const response = await this.getTopicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Kill the session (only the owner can do this).
     * Kill Session
     */
    async killSessionRaw(requestParameters: KillSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponseBase>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling killSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/sessions/{session_id}/kill`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponseBaseFromJSON(jsonValue));
    }

    /**
     * Kill the session (only the owner can do this).
     * Kill Session
     */
    async killSession(requestParameters: KillSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponseBase> {
        const response = await this.killSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform sentiment analysis on all answers to the question and create an LLM summary.
     * Overall Analysis
     */
    async overallAnalysisRaw(requestParameters: OverallAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OverallAnalysis>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling overallAnalysis().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}/analyses/overall`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OverallAnalysisFromJSON(jsonValue));
    }

    /**
     * Perform sentiment analysis on all answers to the question and create an LLM summary.
     * Overall Analysis
     */
    async overallAnalysis(requestParameters: OverallAnalysisRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OverallAnalysis> {
        const response = await this.overallAnalysisRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform sentiment analysis on the current answers.
     * Sentiment
     */
    async sentimentRaw(requestParameters: SentimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SentimentAnalysisPublic>>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling sentiment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}/analyses/sentiment`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SentimentAnalysisPublicFromJSON));
    }

    /**
     * Perform sentiment analysis on the current answers.
     * Sentiment
     */
    async sentiment(requestParameters: SentimentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SentimentAnalysisPublic>> {
        const response = await this.sentimentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transition to the show_analyses stage and notify the clients. This is used to skip an ongoing question or signal that the time is up.
     * Show Analyses Transition
     */
    async showAnalysesTransitionRaw(requestParameters: ShowAnalysesTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionPublic>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling showAnalysesTransition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/sessions/{session_id}/transitions/showanalyses`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionPublicFromJSON(jsonValue));
    }

    /**
     * Transition to the show_analyses stage and notify the clients. This is used to skip an ongoing question or signal that the time is up.
     * Show Analyses Transition
     */
    async showAnalysesTransition(requestParameters: ShowAnalysesTransitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionPublic> {
        const response = await this.showAnalysesTransitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch all answers for the current question and process them to create summaries.
     * Summary
     */
    async summariseRaw(requestParameters: SummariseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SummaryPublic>>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling summarise().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sessions/{session_id}/summarise`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters['sessionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SummaryPublicFromJSON));
    }

    /**
     * Fetch all answers for the current question and process them to create summaries.
     * Summary
     */
    async summarise(requestParameters: SummariseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SummaryPublic>> {
        const response = await this.summariseRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
